<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Parallel on COMP4187 – Parallel Scientific Computing II</title><link>https://teaching.wence.uk/comp4187/exercises/parallel/</link><description>Recent content in Parallel on COMP4187 – Parallel Scientific Computing II</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://teaching.wence.uk/comp4187/exercises/parallel/index.xml" rel="self" type="application/rss+xml"/><item><title>Parallel Hello World</title><link>https://teaching.wence.uk/comp4187/exercises/parallel/hello/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/parallel/hello/</guid><description>Hello, World! # Every programming course has to start with &amp;ldquo;hello world&amp;rdquo;, this is no exception. The goal of this is to familiarise you with compiling and running code using MPI, the parallel library we&amp;rsquo;ll be using, either on Hamilton, or your own machine. So take a look at the setup guide if you haven&amp;rsquo;t already.
A Python version # MPI is a specification for a library-based programming model.</description></item><item><title>Calculating π</title><link>https://teaching.wence.uk/comp4187/exercises/parallel/pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/parallel/pi/</guid><description>Simple MPI parallelism # In this exercise we&amp;rsquo;re going to compute an approximation to the value of π using a simple Monte Carlo method. We do this by noticing that if we randomly throw darts at a square, the fraction of the time they will fall within the incircle approaches π.
Consider a square with side-length $2r$ and an inscribed circle with radius $r$.
Square with inscribed circle</description></item><item><title>1-D domain decomposition</title><link>https://teaching.wence.uk/comp4187/exercises/parallel/domain-decomp-simple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/parallel/domain-decomp-simple/</guid><description>Domain decomposition and data parallelism # In this exercise, we&amp;rsquo;re going to look at some of the implementation steps involved in domain-decomposing a finite difference computation.
The particular case we are going to consider is that of edge detection in grayscale images, and subsequent reconstruction of the original image from the detected eges.
Introduction and background # A particularly simple way of detecting the edges in an image is to convolve it with a Laplacian kernel.</description></item><item><title>Ping-pong latency</title><link>https://teaching.wence.uk/comp4187/exercises/parallel/pingpong/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://teaching.wence.uk/comp4187/exercises/parallel/pingpong/</guid><description>Measuring point-to-point message latency with ping-pong # In this exercise we will write a simple code that does a message ping-pong: sending a message back and forth between two processes.
We can use this to measure both the latency and bandwidth of the network on our supercomputer. Which are both important measurements when we&amp;rsquo;re looking at potential parallel performance: they help us to decide if our code is running slowly because of our bad choices, or limitations in the hardware.</description></item></channel></rss>
<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A petsc4py Rosetta stone #  PETSc itself has rather good documentation, both of the API and a user manual. The PETSc API has very consistent naming. Objects are created with XXXCreate. Where XXX stands for the object type name. For example, to create a vector (which has type Vec):
Vec v; VecCreate(MPI_COMM_WORLD, &v); To create a matrix (which has type Mat):
Mat m; MatCreate(MPI_COMM_WORLD, &m); In python-land, all object names are the same, and namespaced within the PETSc package."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="PETSc and petsc4py"><meta property="og:description" content="A petsc4py Rosetta stone #  PETSc itself has rather good documentation, both of the API and a user manual. The PETSc API has very consistent naming. Objects are created with XXXCreate. Where XXX stands for the object type name. For example, to create a vector (which has type Vec):
Vec v; VecCreate(MPI_COMM_WORLD, &v); To create a matrix (which has type Mat):
Mat m; MatCreate(MPI_COMM_WORLD, &m); In python-land, all object names are the same, and namespaced within the PETSc package."><meta property="og:type" content="article"><meta property="og:url" content="https://teaching.wence.uk/comp4187/lectures/mpi/petsc4py/"><meta property="article:modified_time" content="2024-02-14T14:35:09+00:00"><title>PETSc and petsc4py | COMP4187 – Parallel Scientific Computing II</title><link rel=manifest href=/comp4187/manifest.json><link rel=icon href=/comp4187/favicon.png type=image/x-icon><link rel=stylesheet href=/comp4187/book.min.0cb0b7d6a1ed5d0e95321cc15edca4d6e9cc406149d1f4a3f25fd532f6a3bb38.css integrity="sha256-DLC31qHtXQ6VMhzBXtyk1unMQGFJ0fSj8l/VMvajuzg="></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><div class=book-brand><img class=book-center src=/comp4187/logo.svg alt=Logo><h2><a href=/comp4187>COMP4187 – Parallel Scientific Computing II</a></h2></div><ul><li><span>Administrivia</span><ul><li><a href=/comp4187/setup/jupyter/>Jupyter</a></li><li><a href=/comp4187/setup/mpi/>MPI</a></li></ul></li><li><span>Exercises</span><ul><li><span>Parallel</span><ul><li><a href=/comp4187/exercises/parallel/hello/>Parallel Hello World</a></li><li><a href=/comp4187/exercises/parallel/pi/>Calculating π</a></li><li><a href=/comp4187/exercises/parallel/domain-decomp-simple/>1-D domain decomposition</a></li><li><a href=/comp4187/exercises/parallel/pingpong/>Ping-pong latency</a></li></ul></li><li><a href=/comp4187/exercises/coarse-grid/>Coarse Grid Operator</a></li><li><a href=/comp4187/exercises/finite-differences/>Finite Differences</a></li><li><a href=/comp4187/exercises/two-grid/>Two-Grid Iteration</a></li><li><a href=/comp4187/exercises/norms/>Norms</a></li></ul></li><li><span>Notes</span><ul><li><span>Lectures: Numerics</span><ul><li><a href=/comp4187/lectures/numerics/lecture1/>Lecture 1: Time-stepping</a></li><li><a href=/comp4187/lectures/numerics/lecture2/>Lecture 2: Time-stepping</a></li><li><a href=/comp4187/lectures/numerics/lecture3/>Lecture 3: Time-stepping</a></li><li><a href=/comp4187/lectures/numerics/lecture4/>Lecture 4: Finite Differences</a></li><li><a href=/comp4187/lectures/numerics/lecture5/>Lecture 5: Finite Differences</a></li><li><a href=/comp4187/lectures/numerics/lecture6/>Lecture 6: Finite Differences</a></li><li><a href=/comp4187/lectures/numerics/lecture7/>Lecture 7: Linear Solvers</a></li><li><a href=/comp4187/lectures/numerics/lecture8/>Lecture 8: Linear Solvers</a></li><li><a href=/comp4187/lectures/numerics/lecture9/>Lecture 9: Multigrid</a></li></ul></li><li><a href=/comp4187/lectures/mpi/>MPI</a><ul><li><a href=/comp4187/lectures/mpi/point-to-point/>Point-to-point messaging in MPI</a></li><li><a href=/comp4187/lectures/mpi/point-to-point-nb/>Non-blocking point-to-point messaging</a></li><li><a href=/comp4187/lectures/mpi/collectives/>Collectives</a></li><li><a href=/comp4187/lectures/mpi/advanced/>Advanced topics</a></li><li><a href=/comp4187/lectures/mpi/petsc4py/ class=active>PETSc and petsc4py</a></li><li><a href=/comp4187/lectures/mpi/live-notes/>Term 2: live lecture notes</a></li></ul></li></ul></li><li><a href=/comp4187/coursework/>Coursework 1: Euler-Bernoulli Beam Theory</a></li><li><a href=/comp4187/coursework2/>Coursework 2: multigrid solvers</a></li><li><a href=/comp4187/acknowledgements/>Acknowledgements</a></li><li><span>Past editions</span><ul><li><span>2020/21</span><ul><li><a href=/comp4187/past-editions/2020-21/term1/>Term 1: numerics</a></li><li><a href=/comp4187/past-editions/2020-21/term2/>Term 2: parallel computing</a></li><li><a href=/comp4187/past-editions/2020-21/coursework/>Coursework: a 3D multigrid solver</a></li></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/comp4187/svg/menu.svg class=book-icon alt=Menu></label>
<strong>PETSc and petsc4py</strong>
<label for=toc-control><img src=/comp4187/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#a-petsc4py-rosetta-stone>A petsc4py Rosetta stone</a></li></ul></nav></aside></header><article class=markdown><h1 id=a-petsc4py-rosetta-stone>A petsc4py Rosetta stone
<a class=anchor href=#a-petsc4py-rosetta-stone>#</a></h1><p><a href=https://petsc.org/release>PETSc</a> itself has rather good
documentation, both of the
<a href=https://petsc.org/release/docs/manualpages/>API</a> and a
<a href=https://petsc.org/release/docs/manual/>user manual</a>. The PETSc API
has very consistent naming. Objects are created with <code>XXXCreate</code>.
Where <code>XXX</code> stands for the object type name. For example, to create a
vector (which has type
<a href=https://petsc.org/release/docs/manual/vec/><code>Vec</code></a>):</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#111>Vec</span> <span style=color:#111>v</span><span style=color:#111>;</span>
<span style=color:#111>VecCreate</span><span style=color:#111>(</span><span style=color:#111>MPI_COMM_WORLD</span><span style=color:#111>,</span> <span style=color:#f92672>&amp;</span><span style=color:#111>v</span><span style=color:#111>);</span>
</code></pre></div><p>To create a matrix (which has type
<a href=https://petsc.org/release/docs/manual/mat><code>Mat</code></a>):</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#111>Mat</span> <span style=color:#111>m</span><span style=color:#111>;</span>
<span style=color:#111>MatCreate</span><span style=color:#111>(</span><span style=color:#111>MPI_COMM_WORLD</span><span style=color:#111>,</span> <span style=color:#f92672>&amp;</span><span style=color:#111>m</span><span style=color:#111>);</span>
</code></pre></div><p>In python-land, all object names are the same, and namespaced within
the <code>PETSc</code> package. To create a type <code>XXX</code> we do <code>PETSc.XXX()</code> to
allocate space for the object and then call the <code>create</code> method. For
example, to create a new vector</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-python data-lang=python><span style=color:#f92672>from</span> <span style=color:#111>petsc4py</span> <span style=color:#f92672>import</span> <span style=color:#111>PETSc</span>
<span style=color:#f92672>from</span> <span style=color:#111>mpi4py</span> <span style=color:#f92672>import</span> <span style=color:#111>MPI</span>
<span style=color:#111>v</span> <span style=color:#f92672>=</span> <span style=color:#111>PETSc</span><span style=color:#f92672>.</span><span style=color:#111>Vec</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>create</span><span style=color:#111>(</span><span style=color:#111>comm</span><span style=color:#f92672>=</span><span style=color:#111>MPI</span><span style=color:#f92672>.</span><span style=color:#111>COMM_WORLD</span><span style=color:#111>)</span>
</code></pre></div><p>and to create a new matrix</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-python data-lang=python><span style=color:#f92672>from</span> <span style=color:#111>petsc4py</span> <span style=color:#f92672>import</span> <span style=color:#111>PETSc</span>
<span style=color:#f92672>from</span> <span style=color:#111>mpi4py</span> <span style=color:#f92672>import</span> <span style=color:#111>MPI</span>
<span style=color:#111>m</span> <span style=color:#f92672>=</span> <span style=color:#111>PETSc</span><span style=color:#f92672>.</span><span style=color:#111>Mat</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>create</span><span style=color:#111>(</span><span style=color:#111>comm</span><span style=color:#f92672>=</span><span style=color:#111>MPI</span><span style=color:#f92672>.</span><span style=color:#111>COMM_WORLD</span><span style=color:#111>)</span>
</code></pre></div><p>Subsequent &ldquo;method&rdquo; calls on the created objects take as their first
argument the object on which to call the method. For example
<a href=https://petsc.org/release/docs/manualpages/Vec/VecSetValues.html><code>VecSetValues</code></a>
has prototype</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#111>VecSetValues</span><span style=color:#111>(</span><span style=color:#111>Vec</span> <span style=color:#111>x</span><span style=color:#111>,</span><span style=color:#111>PetscInt</span> <span style=color:#111>ni</span><span style=color:#111>,</span><span style=color:#00a8c8>const</span> <span style=color:#111>PetscInt</span> <span style=color:#111>ix</span><span style=color:#111>[],</span><span style=color:#00a8c8>const</span> <span style=color:#111>PetscScalar</span> <span style=color:#111>y</span><span style=color:#111>[],</span><span style=color:#111>InsertMode</span> <span style=color:#111>iora</span><span style=color:#111>);</span>
</code></pre></div><p>To translate this to <code>petsc4py</code>:</p><ol><li>Remove the type name prefix from the method name <code>VecSetValues -> SetValues</code></li><li>lowercase the first letter <code>SetValues -> setValues</code></li><li>Use this as a method of the <code>Vec</code> object you want</li></ol><p>Since arrays know their size in Python, we can avoid the <code>ni</code> argument
that says how many entries we are inserting. The
<a href=https://petsc.org/release/docs/manualpages/Sys/InsertMode.html#InsertMode><code>InsertMode</code></a>
enum type turns into a enum in <code>PETSc</code>. So <code>PETSc.InsertMode</code></p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-python data-lang=python><span style=color:#111>v</span><span style=color:#f92672>.</span><span style=color:#111>setValues</span><span style=color:#111>(</span><span style=color:#111>indices</span><span style=color:#111>,</span> <span style=color:#111>values</span><span style=color:#111>,</span> <span style=color:#111>addv</span><span style=color:#f92672>=</span><span style=color:#111>PETSc</span><span style=color:#f92672>.</span><span style=color:#111>InsertMode</span><span style=color:#f92672>.</span><span style=color:#111>ADD_VALUES</span><span style=color:#111>)</span>
</code></pre></div><p>I find it often useful to have an IPython window open where I can
autocomplete method names and look at their signatures.</p><p>We will see more examples in the live-coding parts of the lectures.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wenceorg/comp4187/commit/9271858aa631161252031b9cd38d4da1c5c802a0 title="Last modified by Lawrence Mitchell | February 14, 2024" target=_blank rel=noopener><img src=/comp4187/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 14, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/wenceorg/comp4187/edit/main/site/content/lectures/mpi/petsc4py.md target=_blank rel=noopener><img src=/comp4187/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap align-right"><p>© 2020&ndash; <a href=mailto:lawrence@wence.uk>Lawrence Mitchell</a>, <a href=https://annereinarz.github.io>Anne Reinarz</a> & <a href=https://www.dur.ac.uk/>Durham University</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=/comp4187/cc-by-sa.svg></a>
This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#a-petsc4py-rosetta-stone>A petsc4py Rosetta stone</a></li></ul></nav></aside></main></body></html>